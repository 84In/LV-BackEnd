input {
  jdbc {
    jdbc_driver_library => "/usr/share/logstash/mysql-connector-java.jar"
    jdbc_driver_class => "com.mysql.cj.jdbc.Driver"
    jdbc_connection_string => "jdbc:mysql://productservicedb:3306/productservicedb?useSSL=false"
    jdbc_user => "productservice"
    jdbc_password => "productservice2425"

    # Sử dụng tracking_column để chỉ đồng bộ dữ liệu mới hoặc đã thay đổi
    use_column_value => true
    tracking_column => "updated_at"
    tracking_column_type => "timestamp"

    # Lên lịch chạy mỗi phút
    schedule => "* * * * *"

    statement => "
      SELECT
          p.id,
          p.name,
          p.description,
          p.images,
          p.is_active,
          p.category_id,
          p.updated_at,
          p.created_at,
          c.id as category_id,
          c.name as category_name,
          c.code_name as category_code_name,
          c.images as category_images,
          c.description as category_description,
          c.is_active as category_is_active
      FROM
          products p
      JOIN
          categories c ON p.category_id = c.id
      WHERE
          p.updated_at > :sql_last_value
    "

    # Giới hạn số lượng bản ghi để tránh quá tải
    jdbc_paging_enabled => true
    jdbc_page_size => 1000
  }
}

filter {
  # Mapping và chuyển đổi cấu trúc dữ liệu
  mutate {
    rename => {
      "id" => "[id]"
      "name" => "[name]"
      "description" => "[description]"
      "images" => "[images]"
      "is_active" => "[isActive]"

      "category_id" => "[category][id]"
      "category_name" => "[category][name]"
      "category_code_name" => "[category][codeName]"
      "category_images" => "[category][images]"
      "category_description" => "[category][description]"
      "category_is_active" => "[category][isActive]"
    }

    # Thêm một số xử lý để tránh lỗi
    convert => {
      "isActive" => "boolean"
      "[category][isActive]" => "boolean"
    }
  }

  # Chuyển đổi ngày tháng
  date {
    match => [ "createdAt", "yyyy-MM-dd HH:mm:ss", "ISO8601" ]
    target => "createdAt"
    timezone => "UTC"
  }

  date {
    match => [ "updatedAt", "yyyy-MM-dd HH:mm:ss", "ISO8601" ]
    target => "updatedAt"
    timezone => "UTC"
  }

  # Tìm nạp thông tin ProductColors, Variants, Promotions trong một truy vấn riêng
  ruby {
    init => '
      require "json"
      require "java"
      java_import "java.sql.DriverManager"
    '
    code => '
      event = event.to_hash

      # Kết nối đến CSDL để lấy thêm thông tin
      conn = DriverManager.getConnection(
        "jdbc:mysql://productservicedb:3306/productservicedb?useSSL=false",
        "productservice",
        "productservice2425"
      )

      # Truy vấn ProductColors
      stmt = conn.prepareStatement("
        SELECT
          pc.id,
          pc.price,
          pc.is_active,
          c.id as color_id,
          c.name as color_name,
          c.code_name as color_code_name,
          c.color_code,
          c.description as color_description,
          c.is_active as color_is_active,
          GROUP_CONCAT(
            DISTINCT JSON_OBJECT(
              \"id\", s.id,
              \"name\", s.name,
              \"codeName\", s.code_name,
              \"isActive\", s.is_active
            )
          ) as sizes,
          GROUP_CONCAT(
            DISTINCT JSON_OBJECT(
              \"id\", pr.id,
              \"name\", pr.name,
              \"codeName\", pr.code_name,
              \"discountPercentage\", pr.discount_percentage,
              \"startDate\", pr.start_date,
              \"endDate\", pr.end_date,
              \"isActive\", pr.is_active
            )
          ) as promotions
        FROM
          product_color pc
        JOIN
          colors c ON pc.color_id = c.id
        LEFT JOIN
          product_variant pv ON pc.id = pv.product_color_id
        LEFT JOIN
          sizes s ON pv.size_id = s.id
        LEFT JOIN
          product_color_promotion pcp ON pc.id = pcp.product_color_id
        LEFT JOIN
          promotions pr ON pcp.promotion_id = pr.id
        WHERE
          pc.product_id = ?
        GROUP BY
          pc.id, pc.price, pc.is_active,
          c.id, c.name, c.code_name, c.color_code,
          c.description, c.is_active
      ")

      stmt.setString(1, event["id"])
      rs = stmt.executeQuery()

      product_colors = []
      while rs.next
        product_color = {
          "id" => rs.getString("id"),
          "price" => rs.getBigDecimal("price"),
          "isActive" => rs.getBoolean("is_active"),
          "color" => {
            "id" => rs.getString("color_id"),
            "name" => rs.getString("color_name"),
            "codeName" => rs.getString("color_code_name"),
            "colorCode" => rs.getString("color_code"),
            "description" => rs.getString("color_description"),
            "isActive" => rs.getBoolean("color_is_active")
          },
          "productVariants" => JSON.parse("[#{rs.getString('sizes') || ""}]"),
          "promotions" => JSON.parse("[#{rs.getString('promotions') || ""}]")
        }
        product_colors << product_color
      end

      event["productColors"] = product_colors

      conn.close()
      event
    '
  }
}

output {
  elasticsearch {
    hosts => ["http://elasticsearch:9200"]
    index => "products_index"
    document_id => "%{id}"
    action => "update"
    doc_as_upsert => true
  }

  # Ghi log debug
  stdout {
    codec => rubydebug
    codec_options => {
      "enable_metrics" => false
    }
  }
}